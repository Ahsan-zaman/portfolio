import anime from 'animejs/lib/anime.es.js'
import Swiper from 'swiper'
import SwiperCore, { EffectCoverflow } from 'swiper/core'

// configure Swiper to use modules
SwiperCore.use([EffectCoverflow])

const Typed = require('./typed.min.js')

// Hide loading
document.querySelector('.loadanimation').style.display = 'none'
// link avoid default behavior
document.querySelectorAll('#tags ul li a').forEach(a => {
    a.addEventListener('click', e => e.preventDefault())
})

const jquery = require('jquery')
window.$ = window.jQuery = jquery
require('./jquery-3dcloud.min.js')
if (
    !$('#myCanvas').tagcanvas(
        {
            textColour: '#00848c',
            outlineMethod: 'none',
            depth: 1,
            maxSpeed: 0.05,
            minSpeed: 0.005,
            textHeight: 16,
            noSelect: true,
            shuffleTags: true,
            minTags: 45,
            initial: [0.05, -0.03],
        },
        'tags',
    )
) {
    // something went wrong, hide the canvas container
    $('#myCanvasContainer').hide()
}

// Nav
const navBtn = document.querySelector('#navbtn')
const nav = document.querySelector('nav')
const navLinks = document.querySelectorAll('nav a')
navBtn.addEventListener('click', () => {
    nav.classList.toggle('show')
})
navLinks.forEach(a => {
    a.addEventListener('click', () => {
        nav.classList.remove('show')
    })
})
// skills
if ('IntersectionObserver' in window) {
    let skillsObserver = new IntersectionObserver(function (entries, observer) {
        entries.forEach(function (entry) {
            if (entry.isIntersecting) {
                let bar_inner = entry.target.querySelector('.bar-inner')
                bar_inner.style.width = entry.target.getAttribute('data-width')
            } else {
                let bar_inner = entry.target.querySelector('.bar-inner')
                bar_inner.style.width = '0px'
            }
        })
    })

    document.querySelectorAll('.progressbars > .bar').forEach(function (skill) {
        skillsObserver.observe(skill)
    })
} else {
    // Possibly fall back to event handlers here
    document.querySelectorAll('.progressbars > .bar').forEach(bar => {
        let bar_inner = bar.querySelector('.bar-inner')
        bar_inner.style.width = bar.getAttribute('data-width')
    })
}
// Typed
new Typed('.typed', {
    strings: [
        'I develop cool stuff',
        'I fix critical issues',
        'I make your ideas come to life',
    ],
    loop: true,
    loopCount: Infinity,
    typeSpeed: 100,
    backSpeed: 100,
    startDelay: 0,
    backDelay: 1000,
    smartBackspace: true, // Default value
})
// Lazyload images
function canUseWebP() {
    var elem = document.createElement('canvas')
    if (!!(elem.getContext && elem.getContext('2d'))) {
        // was able or not to get WebP representation
        return elem.toDataURL('image/webp').indexOf('data:image/webp') == 0
    }
    // very old browser like IE 8, canvas not supported
    return false
}
var lazyImages = document.querySelectorAll('div.swiper-slide.lazy')
if ('IntersectionObserver' in window) {
    let lazyImageObserver = new IntersectionObserver(function (
        entries,
        observer,
    ) {
        entries.forEach(function (entry) {
            if (entry.isIntersecting) {
                let lazyImage = entry.target
                let url = lazyImage.dataset.url

                if (canUseWebP()) {
                    url = url.split('.jpeg')[0] + '.webp'
                }
                lazyImage.style.backgroundImage = `url(${url})`
                lazyImage.classList.remove('lazy')
                lazyImageObserver.unobserve(lazyImage)
            }
        })
    })

    lazyImages.forEach(function (lazyImage) {
        lazyImageObserver.observe(lazyImage)
    })
} else {
    // Possibly fall back to event handlers here
    lazyImages.forEach(lazyImage => {
        lazyImage.style.backgroundImage = `url(${lazyImage.dataset.url})`
        lazyImage.classList.remove('lazy')
    })
}
// SVG Animation
new anime({
    targets: '#wrapper .lines path',
    strokeDashoffset: [anime.setDashoffset, 0],
    easing: 'easeInOutSine',
    delay: function (el, i) {
        return 1e3 + 100 * i
    },
    duration: function (el, i) {
        return 500 + 800 * i
    },
    direction: 'alternate',
    loop: !0,
})
// Swiper
new Swiper('.swiper-container', {
    effect: 'coverflow',
    grabCursor: true,
    centeredSlides: true,
    slidesPerView: 'auto',
    // freeModeSticky: true,
    coverflowEffect: {
        rotate: 50,
        stretch: 0,
        depth: 100,
        modifier: 1,
        slideShadows: true,
    },
    pagination: {
        el: '.swiper-pagination',
    },
})
